\documentclass[12pt,a4paper]{article}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{hyperref}
\graphicspath{ {./img/} }

\begin{document}
\section{Wersje konsol}
Pierwotnym wydaniem konsoli by³ Family Computer z 1983 roku, w skróconej formie nazywany "Famicom". Famicom oficjalnie nigdy nie zosta³ wydany poza Japoni¹.
Nintendo przygotowuj¹c siê do wydania miêdzynarodowego swojej konsoli do grania podjê³o decyzjê o przeprojektowaniu wygl¹du sprzêtu w celu dostosowania siê do zachodnich odbiorców. Wynikiem tych prac by³ Nintendo Entertainment System, wydany w 1985 roku w USA, rok póŸniej na terenie Europy oraz w 1987 roku w pozosta³ych lokalizacjach w Europie oraz Australii\cite{wikiNES}.
\begin{figure}[H]
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{Nintendo-Famicom-Console-Set-FL}
\caption{Family Computer wraz z kontrolerami\cite{IMG-NintendoFamicomConsoleSetFL}}
\end{minipage}
\hfill
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{NES-Console-Set}
\caption{Nintendo Entertainment System NES-001 wraz z kontrolerem\cite{IMG-NESConsoleSet}}
\end{minipage}%
\end{figure}

Odœwie¿one wersje konsol zosta³y wydane w 1993 roku. Nintendo znacznie zunifikowa³o wygl¹d zewnêtrzny konsol, zachowuj¹c kompatybilnoœæ kartrid¿y dla poszczególnych regionów.
\begin{figure}[H]
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{New_Famicom}
\caption{"New Famicom" wraz z kontrolerem\cite{IMG-NewFamicom}}
\end{minipage}
\hfill
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{NES-101-Console-Set}
\caption{Nintendo Entertainment System NES-101 wraz z kontrolerem\cite{IMG-NES101ConsoleSet}}
\end{minipage}%
\end{figure}

Obok oryginalnych sprzêtów od Nintendo równoczeœnie egzystowa³y konsole podrabiane na masow¹ skalê, w wiêkszoœci by³y to produkty kompatybilne z japoñskim Famicomem. Dok³adna historia nie jest znana; zebrane informacje pozwalaj¹ na stwierdzenie, i¿ pierwsze podróbki zaczê³y pojawiaæ siê pod koniec lat osiemdziesi¹tych oraz zosta³y wyprodukowane na Tajwanie. W latach dziewiêædziesi¹tych nastêpowa³a miniutaryzacja sprzêtów oraz minimalizacja kosztów, co spowodowa³o stopniowo powiêkszane przenoszenie produkcji do Chin oraz drastyczny spadek jakoœci wykonania konsol.
Kreatywnoœæ "piratów" doprowadzi³a do powstania sprzêtów bêd¹cych czymœ innym ni¿ zwyczajna konsola:
\begin{itemize}
  \item Konsole z dwoma gniazdami na kartrid¿e - jedno dla gier z Famicoma, drugie dla gier z NES,
  \item Konsole z dwoma gniazdami na kartrid¿e - jedno standardowo na zewn¹trz obudowy, drugie wewn¹trz obudowy z fabrycznie zamontowan¹ gr¹. Dziêki temu rozwi¹zaniu gdy w zewnêtrznym gnieŸdzie nie by³o zamontowanego kartrid¿a to uruchamia³ siê kartrid¿ wbudowany w konsolê,
  \item Konsola-klawiatura, udaj¹ca komputer - zawsze do³¹czano kartrid¿ z "programami multimedialnymi" które korzysta³y z klawiatury. By³a tu pewna inspiracja oficjalnym Family Basic,
  \item Przenoœna konsola z wbudowanym wyœwietlaczem,
  \item Sprzêty "Plug 'n' Play" o wymyœlnych kszta³tach, czêsto by³y one pozbawione gniazda na kartrid¿e, zatem wbudowane gry musia³y wystarczyæ.
\end{itemize}
\begin{figure}[H]
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{415J8GUp-KL--52577.1589699928}
\caption{Generation NEX - klon z dwoma gniazdami na kartrid¿e, górne jest dla gier Famicom, boczne dla gier NES\cite{IMG-GenerationNEX}}
\end{minipage}
\hfill
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{DY-656-400}
\caption{Daryar DY-400-656 - konsola z wbudowan¹ gr¹ 400 in 1\cite{IMG-DaryarDY400656}}
\end{minipage}%
\end{figure}

\begin{figure}[H]
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{glk_2004}
\caption{GLK-2004 - popularna konsola-klawiatura\cite{IMG-GLK-2004}}
\end{minipage}
\hfill
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{gameaxe_1}
\caption{Game Axe Color - jeden z pierwszych handheldów (2000 rok) odtwarzaj¹cy gry z Famicoma\cite{IMG-Game-Axe-Color}}
\end{minipage}%
\end{figure}


Klony konsoli Nintendo s¹ produkowane po dzieñ dzisiejszy, tyle ¿e czêœciowo wysz³y ze szarej strefy - "Wielkie N" nie ma podstaw prawnych do s¹dzenia siê z firmami gdy¿ wygas³y patenty (TODO: sprawdziæ dok³adnie jak to wygl¹da, lecê z g³owy z tego co kiedyœ czyta³em). Konstrukcje s¹ równie¿ uwspó³czeœniane poprzez zastosowanie gniazd HDMI czy obs³ugê gier z kilku platform jednoczeœnie.
\begin{figure}[H]
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{RetroUSB-AVS-Console-wController-FL}
\caption{RetroUSB AVS - konsola wysokiej jakoœci do której stworzenia u¿yto podzespo³ów z oryginalnych NES\cite{IMG-RetroUSBAVS}}
\end{minipage}
\hfill
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{ret5bk--54484.1567795736.1280.1280}
\caption{Hyperkin RetroN 5 - sprzêt obs³uguj¹cy ogromn¹ iloœæ platform jednoczeœnie, równie¿ kartrid¿e do NES i Famicoma\cite{IMG-RetroN5}}
\end{minipage}%
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{61iW8vUHOJL.-AC-SL1500-}
\caption{NES 620 Games - niskobud¿etowy, wspó³czesny klon konsoli NES z wbudowanymi grami, bez zewnêtrznego gniazda na kartrid¿e\cite{IMG-620Games}}
\end{minipage}%
\end{figure}

Nieoficjalne sprzêty zyska³y popularnoœæ w biedniejszych krajach w których Nintendo nie dystrybuowa³o swoich produktów. "Marki" konsol ró¿ni³y siê miêdzy poszczególnymi pañstwami, niektóre kraje mia³y nawet "oficjalnych dystrybutorów tych¿e podróbek. Mia³y równie¿ miejsce sytuacje, gdzie jeden i ten sam model / typ konsoli by³ sprzedawany pod kilkoma nazwami.\cite{wikiNESClones}

\begin{figure}[htp]
\centering
\includegraphics[width=.5\textwidth]{img/iq502.jpg}
\caption{Micro Genius IQ-502 - wersja konsoli sygnowana mark¹ producenta\cite{IMG-mgiq502}}
\label{fig:figure3}
\end{figure}

\begin{figure}[H]
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{pegiq502}
\caption{Pegasus IQ-502 - wersja Micro Genius IQ-502 przeznaczona na rynek polski, Pegasus to marka firmy Bobmark.\cite{IMG-pegiq502}}
\end{minipage}
\hfill
\begin{minipage}[c]{0.5\linewidth}
\includegraphics[width=\textwidth]{5b6c9ad96c86cb85b53b41c2}
\caption{Dendy Classic 2 - wersja konsoli Micro Genius IQ-502 przeznaczona na rynek rosyjski, Dendy to marka firmy Steepler.\cite{IMG-deniq502}}
\end{minipage}%
\end{figure}
Wszystkie trzy powy¿sze sprzêty to w rzeczywistoœci jeden projekt firmy Micro Genius, ró¿ni¹cy siê logotypami na konsoli oraz padach.

\section{Specyfikacja konsoli}
Procesor (CPU): Ricoh 2A03 (NTSC) / Ricoh 2A07 (PAL), oœmiobitowy mikroprocesor bêd¹cy modyfikacj¹ MOS 6502. Ró¿nice 2A03 / 2A07 wzglêdem produktu MOS Technology s¹ nastêpuj¹ce\cite{nesdoc}:
\begin{itemize}
  \item Deaktywowany tryb dziesiêtny (BCD),
  \item Wbudowany generator dŸwiêkowy,
  \item Obs³uga kontrolerów poprzez porty \$4016 oraz \$4017,
  \item DMA.
\end{itemize}
Mimo i¿ jest to 8-bitowy procesor, mo¿na zaadresowaæ 64 kilobajty pamiêci.
To, jak podzielona jest ta przestrzeñ adresowa przedstawia poni¿sza tabela (podane wartoœci s¹ zapisane w systemie szesnastkowym):
\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Adresy & Rozmiar & Zastosowanie \\
\hline
{\$}0000 - {\$}07FF & {\$}0800 & Wewnêtrzna pamiêæ RAM (dwa kilobajty) \\ \hline
{\$}0800 - {\$}1FFF & {\$}0800 & Duble danych spod adresów {\$}0000 - {\$}07FF (co dwa kilobajty) \\ \hline
{\$}2000 - {\$}2007 & {\$}0008 & Rejestry kontroluj¹ce PPU \\ \hline
{\$}2008 - {\$}3FFF & {\$}1FF8 & Duble danych spod adresów {\$}2000 - {\$}2007 (co osiem bajtów)\\ \hline
{\$}4000 - {\$}4017 & {\$}0018 & Rejestry kontroluj¹ce APU oraz rejestry wejœcia / wyjœcia\\ \hline
{\$}4018 - {\$}401F & {\$}0008 & Dezaktywowany tryb samotestowania \\ \hline
{\$}4020 - {\$}FFFF & {\$}BFE0 & Przestrzeñ do dowolnej dyspozycji dla kartrid¿a \\ \hline 
\end{tabular}
\end{table}
Adresy {\$}4020 - {\$}FFFF s¹ zaadresowane zgodnie z mo¿liwoœciami kartrid¿a (patrz \nameref{mapper}) \cite{nesmemorymap}

Uk³ad graficzny (PPU): Ricoh 2C02, oœmiobitowy uk³ad opracowany przez Nintendo specjalnie dla tej konsoli. Mimo i¿ jest to 8-bitowy procesor, mo¿na zaadresowaæ 16 kilobajtów pamiêci. To, jak podzielona jest ta przestrzeñ adresowa przedstawia poni¿sza tabela (podane wartoœci s¹ zapisane w systemie szesnastkowym):
\begin{table}[H]
\begin{tabular}{|l|l|l|} \hline
Adresy & Rozmiar & Zastosowanie \\ \hline
{\$}0000 - {\$}0FFF & {\$}1000 & \nameref{patterntable} 0 \\ \hline
{\$}1000 - {\$}1FFF & {\$}1000 & \nameref{patterntable} 1 \\ \hline
{\$}2000 - {\$}23FF & {\$}0400 & \nameref{nametable} 0 \\ \hline
{\$}2400 - {\$}27FF & {\$}0400 & \nameref{nametable} 1 \\ \hline
{\$}2800 - {\$}2BFF & {\$}0400 & \nameref{nametable} 2 \\ \hline
{\$}2C00 - {\$}2FFF & {\$}0400 & \nameref{nametable} 3 \\ \hline
{\$}3000 - {\$}3EFF & {\$}0F00 & Dubel danych spod adresów {\$}2000 - {\$}2EFF \\ \hline 
{\$}3F00 - {\$}3F1F & {\$}0020 & \nameref{palette} \\ \hline 
{\$}3F20 - {\$}3FFF & {\$}00E0 & Duble palety barw (co 32 bajty) \\ \hline 
\end{tabular}
\end{table}
Dostêp do wy¿ej wymienionych adresów odbywa siê poprzez adresy CPU: {\$}2006 i {\$}2007.
Gniazdo kartrid¿y: 60-pin (Famicom), 72-pin (NES)

\subsection{Rejestry kontroluj¹ce PPU}
\label{cpuppuregisters}
Adresy {\$}2000 - {\$}2007 oraz {\$}4014 w CPU maj¹ specjalne znaczenie - poprzez nie programista / program mo¿e wp³yn¹æ na dzia³anie uk³adu graficznego konsoli. Zwyczajowe nazwy tych adresów przedstawia poni¿sza tabela \cite{wikicpuppuregisters}:
\begin{table}[H]
\begin{tabular}{|l|l|} \hline
Adres {hex} & Nazwa \\ \hline
{\$}2000 & PPUCTRL \\ \hline
{\$}2001 & PPUMASK \\ \hline
{\$}2002 & PPUSTATUS \\ \hline
{\$}2003 & OAMADDR \\ \hline
{\$}2004 & OAMDATA \\ \hline
{\$}2005 & PPUSCROLL \\ \hline
{\$}2006 & PPUADDR \\ \hline
{\$}2007 & PPUDATA \\ \hline
{\$}4014 & OAMDMA \\ \hline
\end{tabular}
\end{table}
Nazw tych powszechnie u¿ywa siê w kodzie programów zamiast adresów bezpoœrednich oraz w dyskusjach na temat programowania konsol NES / Famicom. Tak¹ zasadê stosujê równie¿ w tym dokumencie.



\subsection{Rejestry kontroluj¹ce APU}
\label{cpuapuregisters}
Adresy {\$}4000 - {\$}4013, {\$}4015 oraz {\$}4017 w CPU maj¹ specjalne znaczenie - poprzez nie programista / program mo¿e wp³yn¹æ na dzia³anie uk³adu dŸwiêkowego konsoli. Zwyczajowe nazwy tych adresów przedstawia poni¿sza tabela \cite{wikicpuapuregisters}:
\begin{table}[H]
\begin{tabular}{|l|l|} \hline
Adres {hex} & Nazwa \\ \hline
{\$}4000 & PL1\_VOL \\ \hline
{\$}4001 & PL1\_SWEEP \\ \hline
{\$}4002 & PL1\_LO \\ \hline
{\$}4003 & PL1\_HI \\ \hline
{\$}4004 & PL2\_VOL \\ \hline
{\$}4005 & PL2\_SWEEP \\ \hline
{\$}4006 & PL2\_LO \\ \hline
{\$}4007 & PL2\_HI \\ \hline
{\$}4008 & TRI\_LINEAR \\ \hline
{\$}400A & TRI\_LO \\ \hline
{\$}400B & TRI\_HI \\ \hline
{\$}400C & NOISE\_VOL \\ \hline
{\$}400E & NOISE\_LO \\ \hline
{\$}400F & NOISE\_HI \\ \hline
{\$}400E & DMC\_FREQ \\ \hline
{\$}400F & DMC\_RAW \\ \hline
{\$}4010 & DMC\_START \\ \hline
{\$}4011 & DMC\_LEN \\ \hline
{\$}4012 & SND\_CHN \\ \hline
\end{tabular}
\end{table}
Nazwy te zosta³y zaczerpniête z biblioteki audio do NES / Famicom - FamiTone2 \cite{famitone2}. U¿ywam ich równie¿ w kodzie Ÿród³owym programu oraz w tym dokumencie.
(TODO: omówienie ka¿dego rejestru, jeszcze nie kodowa³em tego to nie znam szczegó³ów programowych)

\section{Projekt}
\label{project}
W tej sekcji omówiê krok po kroku jak powstawa³ mój w³asny projekt programu na platformê NES. Zacznê od pojedynczych, prostych czynnoœci a¿ po pewnego rodzaju pe³noprawny szkielet takiego projektu zgodny z dobrymi praktykami programowania NES. Nastêpnie zostan¹ omówione krytyczne fragmenty kodu z punktu widzenia ca³ego projektu oraz w³asne rozwi¹zania czêsto spotykanych zagadnieñ.

\setcounter{subsection}{-1}
\subsection{Absolutne minimum}
Kod w pe³ni inicjuj¹cy konsolê jest doœæ rozbudowany, zatem warto zacz¹æ od czegoœ ³atwiejszego... Niech bêdzie to coœ, co poka¿e ¿e jakkolwiek panujemy nad maszyn¹ - zmiana wartoœci pojedynczej komórki pamiêci to rozs¹dny pomys³. Stwórzmy plik Ÿród³owy, nazwijmy go \textit{main.s}. Kod ustalaj¹cy wartoœæ pierwszej komórki RAM na wartoœæ 16 (w systemie szestnastkowym) bêdzie wygl¹da³ nastêpuj¹co:
\begin{verbatim}
lda #$16
sta $0000
\end{verbatim}
Mnemonik \textit{lda} ma wiele odmian - ta zastosowana powy¿ej wczytuje konkretn¹ wartoœæ do wbudowanego w CPU rejestru - akumulatora. Symbol \textit{\#\$} oznacza w³aœnie konkretn¹ wartoœæ liczbow¹ zapisan¹ szesnastkowo.
Mnemonik \textit{sta} kopiuje wartoœæ z akumulatora pod lokacjê podan¹ jako operand; tutaj jest to pierwsza komórka pamiêci RAM (= o adresie \$0000). 

Trzeba zrobiæ jeszcze jedn¹ rzecz - dopisaæ za powy¿szymi poleceniami pêtlê nieskoñczon¹:
\begin{verbatim}
Stop:
    jmp Stop
\end{verbatim}
Trzeba pamiêtaæ o tym i¿ pod naszym programem nie ma ¿adnego systemu operacyjnego czy innego œrodowiska wykonywalnego, zanim nie ma mowy o zakoñczeniu wykonania programu - bez tej pêtli CPU interpretowa³by kolejne bajty jako kod, cokolwiek by tam by³o i wykona³ je.

Jednak¿e jest to o wiele za ma³o ¿eby nawet emulator zrobi³ to, co oczekujemy.
Pierwsza sprawa jest zwi¹zana z ogólnie przyjêtym formatem pliku reprezentuj¹cym ROM programu na platformê NES. Taki plik ma szesnastobajtowy nag³ówek opisuj¹cy szczegó³y programu. Nag³ówek jest potrzebny emulatorom oraz flashcartom do przygotowania adekwatnego œrodowiska uruchomieniowego.
W naszym przypadku nag³ówek bêdzie wygl¹da³ nastêpuj¹co:
\begin{verbatim}
.byte "NES"
.byte $1A
.byte 2
.byte 0
.byte %00000000
.byte %00000000
.byte 0, 0
.byte 0, 0, 0, 0, 0, 0
\end{verbatim}
Pierwsze trzy bajty ("NES") to magiczna wartoœæ.
Kolejny bajt to znak koñca linii.
Po wy¿ej opisanych czterech bajtach programy mog¹ rozpoznaæ i¿ maj¹ do czynienia z plikiem w formacie *.NES.
Bajt pi¹ty to iloœæ 16KB stron pamiêci przeznaczonych na kod wykonywalny. Dwa banki wype³niaj¹ ca³¹ przestrzeñ adresow¹ konsoli.
Kolejny bajt to iloœæ 16KB stron pamiêci przeznaczonych na grafikê. W tym momencie nie potrzebujemy ¿adnej grafiki zatem ustawiamy bajt na zero. W³aœciwie wartoœæ zero ma inny efekt a my skorzystamy z efektu ubocznego tego ale jest to na razie nieistotne - uzyskamy po¿¹dany efekt.
Bajty 7 - 10 to flagi - na tê chwilê interesuj¹ nas tylko i wy³¹cznie bajty odpowiadaj¹ce za \nameref{mapper}. Mapper 0 jest "podstawowy" przez co odpowiedni do prostych programów, zatem go ustawimy. Warto wspomnieæ o tym, jak formowany jest numer mappera: cztery górny bajty pochodz¹ z czterech górnych bajtów bajta ósmego w nag³ówku, cztery dolne bajty pochodz¹ z czterech górnych bajtów bajta siódmego w nag³ówku. (TODO: obrazek lepszy)
Funkcjonalnoœæ bajtów 9 oraz 10 nie interesuje nas w tej chwili, mo¿na je ustawiæ na 0 i zapomnieæ o ich istnieniu
Bajty 11 - 15 to dope³nienie nag³ówka. Wartoœci mog¹ byæ dowolne, zwyjczajowo s¹ to zera.

Druga sprawa ma zwi¹zek z architektur¹ konsoli. Zawsze po uruchomieniu / zresetowaniu konsoli, pierwsz¹ rzecz¹ jak¹ robi procesor to skok bezwzglêdny do adresu uformowanego z bajtów pod adresami \$FFFC (górny bajt) i \$FFFD (dolny bajt). W tym celu modyfikujemy kod w nastêpuj¹cy sposób:
\begin{verbatim}
_INT_Reset:
    lda #$16
    sta $0000

.word _INT_Reset
\end{verbatim}
\textit{.word} to dyrektywa asemblera dzia³aj¹ca jak \textit(.byte), tyle ¿e podajemy wartoœci dwubajtowe zamiast jednobajtowych.
\textit{\_INT\_Reset} to etykieta, zostanie ona zamieniona na konkretny adres przez linker. Dwukropek definiuje etykietê; sam¹ nazwê etykiety traktuje siê jak konkretn¹ wartoœæ szesnastobitow¹. Nadal zostaje problem powiedzenia kompilatorowi oraz linkerowi ¿e ma wstawiæ adres wyznaczony przez etykietê \textit{\_INT\_Reset} dok³adnie pod adres \$FFFC w ROM. Inna sprawa to wskazanie kompilatorowi / linkerowi i¿ nag³ówek nie jest czêœci¹ kodu lecz ma siê znaleŸæ na pocz¹tku pliku reprezentuj¹cego ROM. Oba problemy rozwi¹¿e dyrektywa asemblera \textit{.segment}. Ukoñczony pierwszy program bêdzie wygl¹da³ nastêpuj¹co:
\begin{verbatim}
.segment "HEADER"
.byte "NES"
.byte $1A
.byte 2
.byte 0
.byte %00000000
.byte %00000000
.byte 0, 0
.byte 0, 0, 0, 0, 0, 0

.segment "CODE"
_INT_Reset:
    lda #$16
    sta $0000
Stop:
    jmp Stop

.segment "VECTORS"
.word _INT_Reset
\end{verbatim}
\textit{.segment} to dyrektywa mówi¹ca "poni¿sza treœæ nale¿y do bloku danych zdefiniowanego w pliku konfiguracyjnym linkera podanego jako argument dyrektywy". Na tê chwilê brzmi to niezrozumiale, bo jeszcze nawet nie wspomina³em czym jest plik konfiguracyjny linkera. Jest to plik ze wskazówkami jak ma byæ przeprowadzony proces linkowania plików obiektowych. Do pakietu CC65 jest do³¹czony przyk³adowy plik dla platformy NES jednak¿e wymaga wielu zmian by byc w zgodzie z dobrymi praktykami przyjêtymi przez spo³ecznoœæ wspó³czeœnie programuj¹c¹ na tê konsolê, zatem nic nam po nim i trzeba samemu rozgryŸæ jak stworzyæ w³asny. Stwórzmy nowy plik, nazwijmy go \textit{nes.cfg}. W naszym przypadku plik bêdzie mia³ nastêpuj¹c¹ treœæ:
\begin{verbatim}
MEMORY {
    RAM:        start = $0000,  size = $0800, type = rw, file = "";
    HDR:        start = $0000,  size = $0010, type = ro, file = %O, fill = yes, fillval = $00;
    PRG:        start = $8000,  size = $8000, type = ro, file = %O, fill = yes, fillval = $00;
}

SEGMENTS {
    BSS:      load = RAM, type = bss;
    HEADER:   load = HDR, type = ro;
    CODE:     load = PRG, type = ro,  start = $8000;
    VECTORS:  load = PRG, type = ro,  start = $FFFC;
}
\end{verbatim}
/textit{MEMORY} oraz /textit{SEGMENTS} wyznaczaj¹ grupy zasad steruj¹cych linkerem. Etykiety w sekcji /textit{SEGMENTS} opisuj¹ dwie rzeczy - mapê pamiêci w programie NES za pomoc¹ atrybutu \textit{start} oraz determinuje kolejnoœæ danych w pliku wynikowym dla etykiet z atrybutem /textit{type} o wartoœci \textit{ro}. Kolejnoœæ etykiet mówi jak zostan¹ ustawione dane w pliku wynikowym wyznaczone przez atrybut \textit{load}. Wartoœci tam podane odpowiadaj¹ etykietom zdefiniowanych w sekcji \textit{MEMORY}. Ka¿da wpis definiuje wielkoœæ obszaru, typ dostêpu (odczyt / zapis), w jakim pliku wynikowym siê znajdzie obszar, opcjonalne wype³nienie wartoœciami.
Podsumowuj¹c: \textit{SEGMENTS} odnosi siê do reprezentacji programu na konsoli, \textit{MEMORY} odnosi siê do reprezentacji danych w pliku ROM.

Proszê zwróciæ uwagê, ¿e nazwy segmentów u¿yte w pliku Ÿród³owym programu pokrywaj¹ siê z etykietami w sekcji \textit{SEGMENTS} w pliku konfiguracyjnym.
Z tego dla pliku ROM i¿:
\begin{itemize}
\item na pocz¹tku pliku pojawi siê szesnastobajtowy nag³ówek,
\item nastêpne szesnaœcie kilobajtów zajm¹ dane spod segmentu \textit{CODE}, pozosta³a wolna przestrzeñ zostanie wype³niona zerami
\item potem to, co jest pod segmentem \textit{VECTORS} pos³u¿y linkerowi do nadpisania ostatnich 4 bajty segmentu \textit{CODE} (\$8000 - \$FFFC = \$04)
\end{itemize}

A dla konsoli wynika ¿e:
\begin{itemize}
\item to co znajduje siê za dyrektyw¹ \textit{CODE} w pliku Ÿród³owym zostanie zamapowane na obszar $8000 - $FFFF na konsoli NES,
\item to co znajduje siê za dyrektyw¹ \textit{VECTORS} w pliku Ÿród³owym zostanie zamapowane na obszar $FFFC - $FFFF na konsoli NES, czêœciowo nadpisuj¹c segment \textit{CODE}; jest to jak najbardziej po¿¹dane.
\end{itemize}

Zanim potwierdzimy powy¿sze s³owa, potrzebujemy stworzyæ wynikowy plik ROM. Umieszczamy pliki ca65.exe oraz ld65.exe w tym folderze co nasz kod Ÿród³owy oraz plik konfiguracyjny. Najpierw kompilacja:
\begin{verbatim}
ca65 -o main.o main.s
\end{verbatim}
Argument \textit{-o} pozwala ustaliæ wynikow¹ nazwê pliku obiektowego. Na koñcu podajemy listê plików Ÿród³owych.
Nastêpnie czas na linkowanie:
\begin{verbatim}
ld65 -t nes -o main.nes main.o
\end{verbatim}
Argument \textit{-t} ustala nazwê pliku, pod któr¹ linker znajdzie konfiguracjê. Co wa¿ne, plik musi mieæ rozszerzenie *.cfg którego nie podajemy w powy¿szym poleceniu. Argument \textit{-o} ustala nazwê wynikow¹ pliku ROM. Na koñcu jest lista plików obiektowych.

Zobaczmy jak te dwa narzêdzia stworzy³y plik ROM. Do tego trzeba pos³u¿yæ siê oprogramowaniem zwanym hexedytorem:
\begin{figure}[H]
    \includegraphics[width=\textwidth]{project1}
    \caption{Podgl¹d pliku ROM w programie HxD.}
\end{figure}
Kompilator inaczej zakodowa³ instrukcjê \textit{sta} - zwi¹zane jest to z tak zwanym \nameref{zeropage} i nie ma wp³ywu na poprawnoœæ programu. Kiedy przyjrzymy siê przesuniêciom poszczególnych elementów wzglêdem pocz¹tku pliku zobaczymy, i¿ wszystko jest ustawione tak jak rozkazaliœmy linkerowi.

Teraz uruchommy ROM w \nameref{emulator}. Przywita nas jednokolorowy ekran. Aby sprawdziæ czy komórka pamiêci zawiera po¿¹dan¹ wartoœæ, musimy wybraæ z menu \textit{Debug} opcjê \textit{Memory Tools} i upewniæ siê, ¿e w dropdownie \textit{View} mamy wybran¹ opcjê \textit{CPU Memory}:
\begin{figure}[H]
    \includegraphics[width=\textwidth]{project2}
    \caption{Podgl¹d RAM w emulatorze Mesen.}
\end{figure}
Faktycznie, jest tam wartoœæ szesnaœcie heksadecymalnie, zatem wszystko dzia³a jak powinno.
Jest to dobry przyk³ad na naukê obs³ugi debuggera. Zatem w oknie g³ównym Mesena wybieramy z menu \textit{Debug} opcjê \textit{Debugger}. Okno debuggera mo¿e przyt³oczyæ ogromem informacji, na pocz¹tek skupimy siê na podgl¹dzie kodu. Postawmy breakpoint na adresie \$8000 (pocz¹tek kodu) klikaj¹c LPM na lewo od numeru adresu. Nastêpnie wyci¹gamy na wierzch okno z podgl¹dem RAM aby widzieæ nasz¹ zmienian¹ komórkê pamiêci a nastêpnie z menu debuggera wybieramy \textit{Debug} opcjê \textit{Reset}. Debugger sfokusuje siê na adresie \$8000, co oznaczone jest ¿ó³tym t³em oraz ¿ó³t¹ strza³k¹ wskazuj¹c¹ kolejn¹ instrukcjê do wykonania. Jednak¿e jest pewien problem - w pamiêci ju¿ jest ustawiona wartoœæ \$16. Otó¿ NES nie czyœci pamiêci podczas resetu - program sam musi o to zadbaæ.
\begin{figure}[H]
    \includegraphics[width=\textwidth]{project3}
    \caption{Debugger w emulatorze Mesen.}
\end{figure}
Mimo tego przeœledŸmy wykonanie krok po kroku. W tym celu kilka razy kliknijmy przycisk \textit{Step Into}. Otó¿ po wykonaniu instrukcji \textit{sta} komórka w podgl¹dzie RAM podœwietli³a siê na czerwono - tak w³aœnie Mesen pokazuje, i¿ na danej komórce pamiêci odby³ siê zapis. Po dotarciu do instrukcji \textit{jmp} program "stoi" na instrukcji tak jak chcieliœmy pisz¹c pêtlê nieskoñczon¹.

WprowadŸmy poprawkê ustawiaj¹c¹ wartoœæ na zero tu¿ po resecie, segment \textit{CODE} bêdzie wygl¹da³ nastêpuj¹co:
\begin{verbatim}
_INT_Reset:
    lda #$00
    sta $0000
    lda #$16
    sta $0000
Stop:
    jmp Stop
\end{verbatim}

Skompilujmy a nastêpnie podejrzyjmy w debuggerze jak ta wersja kodu siê wykonuje. Je¿eli nie wy³¹czyliœmy emulatora to breakpoint nadal bêdzie postawiony w po¿¹danym miejscu. Potrzebujemy przejœæ programu dwukrotnie - pierwsze przejœcie ustali wartoœæ w RAM na \$16, a w drugim zobaczymy dwukrotne ustawianie wartoœci - najpierw na zero, potem ponownie na \$16.
Warto równie¿ popatrzeæ na sekcjê \textit{CPU Status} na prawo od naszego kodu w debuggerze a dok³adniej pole \textit{A} - to jest w³aœnie rejestr procesora, akumulator.

Za nami bardzo d³ugie wprowadzenie a w³aœciwie nic wielkiego nie zaprogramowaliœmy. S¹ to solidne fundamenty do dalszego kodowania, bez nich prêdzej czy póŸniej wychodz¹ braki tej podstawowej wiedzy, niezrozumienie bardziej skomplikowanych zagadnieñ. Narzêdzia deweloperskie emulatora to równie¿ potê¿na rzecz któr¹ warto wykorzystywaæ przy ka¿dej napotkanej w¹tpliwoœci / problemie, pozwalaj¹ zajrzeæ do "czarnej skrzynki" jak¹ niejako jest NES daj¹c podgl¹d na procesy zachodz¹ce w uk³adach scalonych nawet w mikroskali jak¹ jest pojedyncza instrukcja procesora.

\subsection{W³aœciwe "Hello World"}
NES to konsola maj¹ca wiele pu³apek czyhaj¹cych na programistê któremu brakuje wiedzy technicznej na temat tego sprzêtu. Poni¿ej omówiê program który w pe³ni poprawnie zainicjuje konsolê do dzia³ania. Jest on wspólnym opracowaniem wielu ludzi wspó³czeœnie zajmuj¹cych siê t¹ tematyk¹ \cite{initcode}. Jest tam trochê dzia³añ które mo¿na by pomin¹æ gdy¿ prawid³owe wartoœci mog¹ ju¿ tam byæ ustawione, jednak¿e nie musi byæ to regu³a oraz pozostawi³o by to konsolê w stanie niezdefiniowanym nara¿aj¹c na trudne w zdebuggowaniu b³êdy. Przedstawiê ten kod go w kilku fragmentach. Nadal kod bêdzie dopisywany do pliku main.s, nale¿y to robiæ na samym pocz¹tku segmentu \textit{CODE}. Oto pierwszy z nich:
\begin{verbatim}
reset:
    sei
    cld
    ldx #$40
    stx $4017
    ldx #$FF
    txs
    inx
    stx $2000
    stx $2001
    stx $4010
\end{verbatim}
Opkod \textit{sei} to instrukcja wy³¹czaj¹ca odnotowywanie przez CPU przerwañ niemaskowalnych. To znaczy ¿e procesor nie bêdzie reagowa³ na przerwania, dziêki czemu nie bêdzie zak³óca³ wykonania naszego kodu inicjuj¹cego. Przerwania nadal nadal siê "wewnêtrznie", cyklicznie wystêpuj¹!
Instrukcja \textit{cld} wy³¹cza tryb dziesiêtny. Oczywiœcie wariant procesora wbudowany w NES ma wyciêty tryb dziesiêtny, jednak¿e debuggery ogólnie dzia³aj¹ce na kodzie napisanym pod MOS 6502 opieraj¹ siê na tym, i¿ ta konkretna flaga jest ustawiona.
Nastêpnie pojawiaj¹ siê \textit{stx} oraz \textit{ldx} - odpowiedniki instrukcji \textit{sta} oraz \textit{lda} tyle ¿e dla rejestru X. Jest jeszcze analogiczna par¹ mnemoników dla rejestru Y (\textit{sty}, \textit{ldy}).
Wartoœæ \#\$40 to w³aœciwie ustawienie bitu numer szeœæ. Ta wartoœæ jest wysy³ana pod port \$4017 CPU w celu wy³¹czenia przerwañ generowanych przez dodatkowe podzespo³y rozszerzaj¹ce mo¿liwoœci kartrid¿a.
Nastêpnie odbywa siê inicjacja stosu - wartoœæ \$FF jest ³adowana do rejestru X, mnemonik \textit{txs} kopiuje tê wartoœæ z rejestru X do rejestru wskaŸnika stosu. Proszê zauwa¿yæ ¿e to dolna czêœæ wskaŸnika stosu - górna zostanie ustawiona póŸniej.
W rejestrze X nadal jest wartoœæ \$FF. Instrukcja \textit{inx} inkrementuje X o jeden, zatem rejestr siê "przekrêca", ustawiaj¹c siê na wartoœæ 0. Trzy kolejne zapisy pod adresy \$2000, \$2001 oraz \$4010 to wy³¹czenie wszelkich flag którymi te trzy rejestry zarz¹dzaj¹. Najwa¿niejsze z nich to dezaktywacja \nameref{nmi} - znaczy to tyle ¿e przestanie wykonywaæ siê to przerwanie (rejestr \$2000), wy³¹czenie renderowania ekranu (\$2001), wy³¹czenie przerwania DMC którego dedykowanym zastosowaniem jest prawid³owe odgrywanie digitalizowanych próbek dŸwiêkowych (\$4010).

Powy¿sze instrukcje s¹ powi¹zane z kolei krokiem - trzeba odczekaæ dwie klatki obrazu aby uk³ad graficzny ustabilizowa³ siê oraz zacz¹³ pracowaæ w pe³ni prawid³owo \nameref{ppu} (TODO: dok³adne wskazanie omówienia co tam siê dzieje). Mamy wy³¹czone \nameref{nmi} ale jest jeszcze jedna metoda na odliczenie klatek obrazu. PPU zawsze sygnalizuje moment w którym zakoñczy³ rysowanie klatki obrazu (rozpocznie wygaszanie pionowe obrazu) poprzez ustawienie najwy¿szego bitu w rejestrze flag \$2002:
\begin{verbatim}
vblankwit1:
    bit $2002
    bpl vblankwait1    
\end{verbatim} 
Opkod \textit{bit} ma specyficzne dzia³anie: wykonuje operacjê bitow¹ "akumulator AND operand instrukcji \textit{bit}", nastêpnie "zapomina" wynik za to ustawia flagê Z (flaga zero) jeœli wynik operacji AND by³ równy zero. Oprócz tego zawsze kopiuje bit szósty operandu do flagi V (flaga przepe³nienia), a siódmy do flagi N (flaga wartoœci ujemnej). W akumulatorze mamy w tej chwili wartoœæ zero - w jego przypadku akurat mamy gwarancjê ¿e po uruchomieniu konsoli / resecie zawsze bêdzie to wartoœæ zero a wczeœniej w kodzie nigdzie nie manipulowaliœmy tym rejestrem. Przyk³ad powinien rozjaœniæ:
\begin{verbatim}
W rejestrze A mamy wartoœæ zero.
Chcemy wykonaæ operacjê \textit{bit} na wartoœci #$80 (%10000000 binarnie).
Zatem wynik operacji:
    bit    #$80
bêdzie nastêpuj¹cy:
    %00000000
AND %10000000
    %00000000
a w rezultacie:
\begin{enumerate}
\item flaga Z zostanie ustawiona,
\item flaga V zostanie wyzerowana,
\item flaga N zostanie ustawiona.
\end{enumerate}
\end{verbatim}
Powy¿sze omówienie instrukcji \textit{bit} to sytuacja to¿sama z t¹, gdy w³aœnie PPU da³o znak ¿e skoñczy³o rysowaæ klatkê.
Instrukcja \textit{bpl} to jeden ze skoków warunkowych - dla \textit{bpl} skok do etykiety podanej jako operand ma miejsce, gdy flaga wartoœci ujemnej jest wyzerowana.
Zatem program bêdzie "krêci³ siê w miejscu" dopóki flaga jest ujemna. Przestanie to robiæ gdy opkod \textit{bit} ustawi flagê N, a to siê stanie gdy PPU skoñczy rysowaæ klatkê oraz ustawi najwy¿szy bit w rejestrze \$2002. W ten sposób nale¿y rozumieæ zaprezentowany kod. Dzia³a to poprawnie tak¿e dlatego, i¿ po odczycie rejestru \$2002 najwy¿szy bit zostanie wyczyszczony, zatem nie ma mowy o sytuacji gdzie PPU ustawi³o tê flagê jakimœ cudem wczeœniej a teraz jest w trakcie rysowania kolejnej klatki.

Mamy jeszcze ca³¹ klatkê obrazu do wykorzystania, zatem zróbmy coœ po¿ytecznego: czyszczenie RAM:
\begin{verbatim}
clear_memory:
    lda #$00
    sta $0000, x
    sta $0100, x
    sta $0200, x
    sta $0300, x
    sta $0400, x
    sta $0500, x
    sta $0600, x
    sta $0700, x
    inx
    bne clear_memory
\end{verbatim}
Na pocz¹tek warto odnotowaæ ¿e rejestr X zawiera w tej chwili nadal wartoœæ zero. Instrukcja \textit{sta} ma kilka wariantów, powy¿szy korzysta z jednego z trybów procesora zwanego "Absolute X". Dzia³a to tak, ¿e w celu wyznaczenia adresu pod którym zmodyfikuje siê wartoœæ do konkretnego adresu w pierwszym operandzie \textit{sta} dodawana jest wartoœæ rejestru X, bêd¹cego zarazem drugim operandem. Na koñcu pêtli jest inkrementacja tego¿ rejestru oraz instrukcja \textit{bne} - kolejny skok warunkowy do etykiety podanej jako operand maj¹cy miejsce, gdy flaga Z ma wartoœæ zero. Zauwa¿my ¿e pierwsze sprawdzenie rejestru X odbywa siê gdy ma on wartoœæ jeden, zatem flaga Z nie bêdzie ustawiona dziêki czemu bêdzie mia³ skok do podanej etykiety. Tak bêdzie a¿ do momentu, gdy X siê "przekrêci" i wska¿e wartoœæ zero. W tym momencie wszystkie komórki RAM (zakres \$0000 - \$07FF) bêd¹ zawieraæ wartoœci zero. 
Sam proces zerowania odbywa siê tak, ¿e w pierwszym kroku wyzerowane bêd¹ komórki \$0000, \$0100, \$0200, ... , \$0700. W drugim: \$0001, \$0101, \$0201, ... , \$0701. W ostatnim, dwieœcie piêædziesi¹tym szóstym kroku zerowanie odbêdzie siê pod adresami \$00FF, \$01FF, \$02FF, ... , \$07FF.

Teraz czas na czekania na koniec drugiej klatki obrazu:
\begin{verbatim}
vblankwait2:
    bit $2002
    bpl vblankwait2
\end{verbatim}
Dzia³anie analogiczne do oczekiwania na pierwsze rozpoczêcie wygaszania obrazu.

W tym momencie PPU jest ju¿ gotowe do pracy. Wykorzystajmy to wyœwietlaj¹c jednokolorowy obraz we fioletowym kolorze. Zrobimy to tak:
\begin{verbatim}
    lda #%01100000
    sta $2001
\end{verbatim}
To co w³aœciwe ³adujemy do rejestru \$2001 to flagi ustawiaj¹ce "intensywny odcieñ" kolorów czerwonego oraz zielonego (TODO: referencja do opisu rejestru \$2001). Jest to graficzna funkcjonalnoœæ PPU, polegaj¹c¹ na tym i¿ wszystkie kolory w palecie kolorów (TODO: link) zmieniaj¹ odcieñ na bardziej czerwony, zielony, niebieski b¹dŸ dowolny miks nich. Nie bêdziemy wchodziæ w ten temat, gdy¿ jest to niemal nieu¿ywana funkcjonalnoœæ a jej praktyczne zastosowanie jest minimalne. Po prostu przyda nam siê ona do szybkiego testu czy uk³ad graficzny dzia³a poprawnie. O palecie barw bêdzie w dalszej czêœci dokumentu.

Zanim skompilujemy program to mo¿emy ju¿ usun¹æ kawa³ek kodu który napisaliœmy w poprzedniej podsekcji - nie ma potrzeby oddzielnego ustawiania komórki RAM o adresie \$0000 na zero. Finalny kod wygl¹da nastêpuj¹co:
\begin{verbatim}
.segment "HEADER"
.byte "NES"
.byte $1A
.byte 2
.byte 0
.byte %00000000
.byte %00000000
.byte 0, 0
.byte 0, 0, 0, 0, 0, 0

.segment "CODE"
_INT_Reset:
    sei
    cld
    ldx    #$40
    stx    $4017
    ldx    #$FF
    txs
    inx
    stx    $2000
    stx    $2001
    stx    $4010
    
vblankwait1:
    bit    $2002
    bpl    vblankwait1    
    
clear_memory:
    lda    #$00
    sta    $0000, x
    sta    $0100, x
    sta    $0200, x
    sta    $0300, x
    sta    $0400, x
    sta    $0500, x
    sta    $0600, x
    sta    $0700, x
    inx
    bne    clear_memory

vblankwait2:
    bit $2002
    bpl vblankwait2    
    
    lda #%01100000
    sta $2001
    
    lda #$16
    sta $0000
Stop:
    jmp Stop

.segment "VECTORS"
.word _INT_Reset
\end{verbatim}

Nie ma potrzeby zmiany pliku konfiguracyjnego linkera. Budowê pliku ROM przeprowadzamy tymi samymi komendami co poprzednio:
\begin{verbatim}
ca65 -o main.o main.s
ld65 -t nes -o main.nes main.o
\end{verbatim}

Jeœli nie wy³¹czyliœmy poprzednio breakpointu w debuggerze to po otworzeniu œwie¿o skompilowanego ROM w emulatorze wykonanie programu bêdzie wstrzymane przed pierwsz¹ instrukcj¹. W tym celu trzeba wejœæ w okno debuggera i nacisn¹æ przycisk \textit{Continue}.
\begin{figure}[H]
    \includegraphics[width=\textwidth]{project4}
    \caption{Przycisk \textit{Continue} w debuggerze emulatora Mesen.}
\end{figure}

Po udanym procesie budowania naszym oczom powinien ukazaæ siê jednokolorowy, fioletowy ekran:
\begin{figure}[H]
    \includegraphics[width=\textwidth]{project5}
    \caption{Wynik dotychczas napisanego kodu.}
\end{figure}

Warto poœwiêciæ chwilê podgl¹dowi w debuggerze tego, jak wykonuje siê kod w celu lepszego zrozumienia. Warte odnotowania jest, i¿ debugger u¿ywa specjalnych etykiet dla niektórych rejestrów - s¹ to zwyczajowe nazwy tych¿e. Po najechaniu na tak¹ etykietê ujrzymy szczegó³owy opis danego rejestru. Po prawej stronie okna jest lista wszystkich takich rejestrów w okienku \textit{Labels}, w³aœnie tam mo¿na równie¿ edytowaæ treœæ pokazuj¹c¹ siê w dymku. Bêdzie o tym mowa jeszcze póŸniej. 
Druga sprawa to w sekcji \textit{PPU Status} zaznaczone s¹ checkboxy \textit{Intensify Red} oraz \textit{Intensify Green} - to w³aœnie bity które ustawiliœmy w rejestrze \$2001. Mo¿emy odznaczyæ / zaznaczyæ te pola gdy zatrzymamy wykonanie programu. Zmiany bêd¹ widoczne po ponownym uruchomieniu wykonania kodu, polecam poeksperymentowaæ.
\begin{figure}[H]
    \includegraphics[width=\textwidth]{project6}
    \caption{Podgl¹d stanu flag "intensywnych odcieni" w debuggerze.}
\end{figure}

\subsection{Paleta kolorów}
Uk³ad graficzny NES ma grupê zdefiniowanych kolorów jakie mo¿na uzyskaæ. Ta grupa liczy szeœædziesi¹t cztery ró¿ne barwy:
\begin{figure}[H]
    \includegraphics[width=\textwidth]{Savtool-swatches}
    \caption{Wszystkie mo¿liwe kolory do uzyskania na konsoli NES.}
\end{figure}
U³o¿enie nie jest przypadkowe - na krañcach mamy odcienie szaroœci, w œrodku kolory s¹ u³o¿one w pionie wed³ug jasnoœci, w poziomie na podstawie ko³a barw (TODO: na pewno?). £atwo zauwa¿yæ ¿e iloœæ ró¿nych kolorów jest mniejsza: jest dziesiêæ identycznych czerni oraz dwa razy wystêpuje kolor bia³y. Odejmuj¹c duplikaty dostajemy 54 unikalne barwy. Jest jeszcze jedna istotna sprawa - kolor oznaczony jako \$0D sprawia problemy niektórym odbiornikom telewizyjnym które interpretuj¹ go jako sygna³ synchronizacyjny co powoduje problemy z poprawnym wyœwietlaniem obrazu, tote¿ zaleca siê go nie stosowaæ. Z tego powodu ten kolor równie¿ nazywa siê potocznie "ciemniejszym ni¿ czerñ".

To te¿ nie jest tak, ¿e mo¿emy u¿ywaæ wszystkich kolorów w danej chwili. PPU ma dedykowany obszar pamiêci na ograniczon¹ iloœæ kolorów. Podzielony jest on kolory t³a (background / BGR) oraz kolory sprite'ów (sprites / SPR). Obie grupy maj¹ po cztery palety. Te kolei maj¹ cztery kolory. Jednak to nie koniec Tutaj napotykamy na kolejne ograniczenie - jeden z kolorów jest wspólny dla wszystkich palet a zarazem pe³ni rolê koloru przezroczystego dla sprite'ów. Przyk³ad:
\begin{figure}[H]
    \includegraphics[width=\textwidth]{project7}
    \caption{Podgl¹d obecnie ustawionej palety barw w emulatorze Mesen.}
\end{figure}
Po lewej stronie s¹ kolory t³a, po prawej sprite'ów. Ka¿da paleta zajmuje jeden rz¹d. Pierwszy kolor w ka¿dej palecie to kolor wspólny, tutaj jest to czerñ (oznaczenie \$0F). Palety przyjê³o siê numerowaæ od zera. Zatem paleta numer 0 dla t³a zawiera cztery barwy - czarny (wspólny, \$0F), niebieski (\$01), szary (\$00), niebieski (\$01). Barwy jak najbardziej mog¹ siê powtarzaæ w ramach palety. Paleta numer 1 dla t³a zawiera kolory: czarny (wspólny, \$0F), granatowy (\$02), granatowy (\$02), szary (\$00). Barwy mog¹ powtarzaæ siê równie¿ miêdzy ró¿nymi paletami. Ni¿ej s¹ palety numer 2 oraz 3, skonstruowane analogicznie. Czerñ bêdzie kolorem domyœlnie wype³niaj¹cym ekran jeœli nie bêdzie w tym miejscu innej barwy.
Palety sprite'ów te¿ maj¹ cztery komórki na kolory. Przeanalizujmy paletê numer zero: czarny (wspólny, \$0F), niebieski (\$01), jasnoró¿owy (\$34), fioletowy (\$03). Kolejne palety skonstruowane s¹ analogicznie. W tym przypadku czarny bêdzie kolorem przezroczystym - piksel z tym kolorem bêdzie zast¹piony kolorem t³a. Zatem w³aœciwie ka¿da tego typu paleta ma tylko trzy unikalne kolory.

Podsumowuj¹c - w danej chwili program mo¿e mieæ do dyspozycji 25 unikalnych kolorów: cztery kolory z palety BGR 0, plus po trzy kolory z palet BGR 1 - 3 (powtarza siê jeden kolor wystêpuj¹cy w palecie zero) ³¹cznie dziewiêæ, plus po trzy kolory z palet SPR 0 - 3.

Skorzystajmy z przyswojonej wiedzy i ustalmy paletê kolorów w naszym programie. Przyda siê ona do dalszych zagadnieñ. Najpierw opracujemy tablicê z wartoœciami po¿¹danych kolorów:
\begin{verbatim}
palette:
	.byte $0f, $01, $21, $31	; BGR 0
	.byte $0f, $02, $22, $32	; BGR 1
	.byte $0f, $03, $23, $33	; BGR 2
	.byte $0f, $04, $24, $34	; BGR 3
	.byte $0f, $05, $25, $35	; SPR 0
	.byte $0f, $06, $26, $36	; SPR 1
	.byte $0f, $07, $27, $37	; SPR 2
	.byte $0f, $08, $28, $38	; SPR 3
\end{verbatim}
Umieszczamy j¹ za pêtl¹ nieskoñczon¹ \textit{Stop}. Symbol œrednika oznacza komentarz - to co napiszemy po œredniku nie jest traktowane jak kod. Tutaj u¿yliœmy komentarza do opisu które dane odpowiadaj¹ której palecie barw.
To co jest po etykiecie \textit{palette} traktujemy jako jeden ci¹g³y obszar. Podzia³ na wiersze zosta³ zastosowany dla czytelnoœci.
Zatem mamy do wczytania 32 wartoœci. Jak to zrobiæ? Musimy napisaæ odpowiedni¹ pêtlê, jednak¿e najpierw wpiszmy te wartoœci do pamiêci RAM pod adresy \$0010 - \$002F - podmienimy to na wysy³anie danych do PPU za chwilê. Poni¿szy kod umieszczamy po pêtli \textit{vblankwait2} ale przed konfiguracj¹ rejestru \$2001:
\begin{verbatim}
	ldx #$00
_loop_Palette:
	lda palette, x
	sta $0010, x
	inx
	cpx #$20
	bne _loop_Palette
\end{verbatim}
Przed rozpoczêciem pêtli w rejestrze X umieszczamy pocz¹tkow¹ wartoœæ licznika. Nastêpnie mamy pêtle która zajmuje siê przetwarzaniem danych. Mnemonik \textit{lda} równie¿ ma tryb "absolute X" który ju¿ widzieliœmy w wykonaniu instrukcji \textit{sta} przy czyszczeniu RAM. Zatem kod \textit{lda palette, x} za³aduje bajt danych spod adresu (etykieta \textit(palette) + wartoœæ w rejestrze X). Nastêpnie wrzucamy tê wartoœæ do RAM, inkrementujemy X. Kolejna instrukcja, \textit{cpx} porównuje wartoœæ znajduj¹c¹ siê w rejestrze X z wartoœci¹ podan¹ jako operand. Istniej¹ równie¿ analogiczne operacje do porównywania dla pozosta³ych rejestrów {cmp dla rejestru A, cpy dla rejestru Y}. Rezultatem porównania jest ustawienie odpowiednich flag procesora. Tutaj porównanie jest z wartoœci¹ \#\$20 {32 dziesiêtnie} czyli wielkoœci¹ naszych danych, czyli po tylu bajtach chcemy zakoñczyæ przetwarzanie. ¯eby to zapewniæ po porównaniu stawiamy skok warunkowy, tutaj jest to \textit{bne}. Dlaczego? W³aœciwie warunek koñca pêtli mo¿na uj¹æ jako \textit{rejestr X == \#\$20} i tylko w tym jednym przypadku zostanie ustawiona flaga procesora Z; w innych przypadkach bêdzie ona wyzerowana, a co za tym idzie \textit{bne} bêdzie skaka³ na pocz¹tek pêtli zawsze z wyj¹tkiem sytuacji w której w³aœnie chcemy zakoñczyæ pêtli - wtedy \textit{bne} "przepuœci" wykonywanie programu dalej.

Powy¿szy kod to pewien wzorzec na przetwarzanie zbiorów danych, które ma czêsto miejsce w kodzie.

Czas na kompilacje oraz uruchomienie. Po za³adowaniu ROMu do emulatora i wejœciu do podgl¹du pamiêci powinniœmy ujrzeæ nastêpuj¹cy widok:
\begin{figure}[H]
    \includegraphics[width=\textwidth]{project8}
    \caption{Podgl¹d RAM w emulatorze Mesen z przetworzonymi danymi.}
\end{figure}
Uda³o siê za³adowaæ poprawnie przetworzyæ dane, zatem czas na przes³anie ich do PPU.

Przypominam i¿ program komunikuje siê bezpoœrednio wy³¹cznie z CPU, zatem nie mo¿emy u¿yæ instrukcji \textit{sta} i tylko zmieniæ adresu docelowego. CPU ma dedykowane adresy do komunikacji z PPU i ich w³aœnie u¿yjemy.
Najpierw przygotowujemy PPU powiadamiaj¹c poprzez CPU o adresie do którego chcemy uzyskaæ dostêp, umieszczaj¹c poni¿szy kod po pêtli \textit{vblankwait2} a przed pêtl¹ przetwarzaj¹c¹ dane:
\begin{verbatim}
   lda	$2002
	lda	#$3f
	sta	$2006
	lda	#$00
	sta   $2006
\end{verbatim}
Odczyt rejestru \$2002 s³u¿y do zresetowania adresu wewnêtrznego PPU. Uk³ad graficzny ca³y czas wykonuje jakieœ operacje u¿ywaj¹c w³aœnie tego wewnêtrznego adresu a my musimy mu "przeszkodziæ" przerywaj¹c domyœln¹ pracê.
Nastêpnie ³adujemy górn¹ czêœæ adresu pocz¹tku palety te³ (\#\$3f) i wysy³amy do adresu \$2006 CPU. Ten z kolei przekazuje go PPU którego zadaniem jest ustawiæ tê wartoœæ w swoim wewnêtrznym adresie. Kolejna para \textit{lda / sta} przesy³a dolny bajt adresu pocz¹tku palety te³. Adres \$3F00 to pierwsza wartoœæ palety BGR 0.

Kolejna czynnoœæ to faktyczne przesy³anie danych. Wymaga to ma³ej zmiany w pêtli, podmienienia instrukcji \textit{sta} na nastêpuj¹c¹:
\begin{verbatim}
	sta $2007
\end{verbatim}
Instrukcja ta robi dwie rzeczy: poprzez poœrednika - CPU wysy³a zawartoœæ rejestru A pod wczeœniej ustalony adres w PPU, a samo PPU zwiêksza wewnêtrzny adres o jeden.

Zatem ca³a pêtla bêdzie wygl¹da³a tak:
\begin{verbatim}
_loop_Palette:
	lda palette, x
	sta $2007
	inx
	cpx #$20
	bne _loop_Palette
\end{verbatim}
Rozwijaj¹c w¹tek ta pêtla przeœle zawartoœæ tablicy \textit{palette} do PPU bajt po bajcie. W pierwszym kroku pierwsza wartoœæ z tablicy wyl¹duje pod adresem \$3F00, w drugim druga wartoœæ znajdzie siê pod adresem \$3F01, ... , w ostatnim, trzydziestym drugim kroku ostatnia wartoœæ z tablicy zostanie umieszczona pod adresem \$3F1F.

PPU przechowuje palety t³a pod adresami \$3F00 - \$3F0F a adresu sprite'ów pod adresami \$3F10 - \$3F1F. W powy¿szych kodzie korzystamy z faktu "ci¹g³oœci" tego obszaru - nie musimy osobno ustawiaæ adresu na pocz¹tek obszaru palet sprite'ów, przesy³aj¹c za jednym zamachem wszystkie dane.

Czas na przetestowanie zmian. Po uruchomieniu emulatora pierwsz¹ spraw¹ mog¹c¹ rzuciæ siê w oczy jest inny kolor t³a w oknie g³ównym w przypadku gdy domyœlnie emulator mia³ ustawione inny "wspó³dzielony" kolor.  W celu sprawdzenia czy palety zosta³y pomyœlnie ustawione, nale¿y przejœæ do menu \textit{debug -> PPU Viewer} a nastêpnie do zak³adki \textit{Palette Viewer}. 
\begin{figure}[H]
    \includegraphics[width=\textwidth]{project9}
    \caption{Podgl¹d ustalonej przez program palety kolorów w emulatorze Mesen.}
\end{figure}
Na obrazku powy¿ej wygl¹da na to, ¿e wszystko dzia³a jak nale¿y. To okno pozwala równie¿ na ustawienie innych kolorów w trakcie dzia³ania, wystarczy klikn¹æ w odpowiedni¹ komórkê a nastêpnie wybraæ po¿¹dany kolor; zmiana nast¹pi natychmiastowo. Przydatna sprawa przy eksperymentowaniu.

\subsection{Grafika - Sprite'y}














\subsection{Grafika - T³o}












\subsection{Synchronizacja pêtli g³ównej programu z \nameref{nmi}}












\subsection{Rozpoznawanie regionu konsoli}










\subsection{Drugi ekran z t³em, przewijanie ekranu}









\subsection{Podprogramy / procedury}







\subsection{Liczenie czasu}










\subsection{Animacja grafiki}







\subsection{Podzia³ projektu na pliki}










\subsection{Obs³uga kontrolera}
















\subsection{Implementacja trybów programu}









\section{Informacje o platformie}
\label{info}

\subsection{Zero Page}
\label{zeropage}

\subsection{NMI}
\label{nmi}

\subsection{PPU}
\label{ppu}

\subsection{Mapper}
\label{mapper}

\subsection{Pattern Table}
\label{patterntable}

\subsection{Nametable}
\label{nametable}

\subsection{Paleta barw}
\label{palette}

\section{Narzêdzia}
\subsection{CA65}
Strona projektu: https://cc65.github.io/
CA65 jest czêœci¹ wiêkszego pakietu zwanego CC65. Jest on zbiorem narzêdzi do kompilacji kodu napisanego w jêzyku C na sprzêty z procesorem MOS 6502. Za to CA65 jest asemblerem pod ten sam procesor.
W przypadku NES jêzyk C stanowi problem wydajnoœciowy, gdy¿ plik wynikowy który powstaje po kompilacji kodu w C jest znacznie wolniejszy ni¿ odpowiednik asemblerowy; warto pamiêtaæ i¿ ta konsola jest wielokrotnie mniej wydajna ni¿ wspó³czesne sprzêty. St¹d moja decyzja o pisaniu kodu tylko i wy³¹cznie w asemblerze.

(UWAGI: zestaw kompilator plus linker zas³uguje na wiêksze wyró¿nienie od ni¿ej opisanych programów pomocniczych do grafiki czy muzyki; do przemyœlenia miejsce w dokumencie)

\subsection{Mesen}
\label{emulator}
Emulator znacz¹co wspiera proces tworzenia oprogramowania pod NES, gdy¿ zawiera wiele narzêdzi pozwalaj¹cych na zbadanie zachowania naszego programu. Aby mieæ dostêp do narzêdzi deweloperskich, musimy w menu \textit{Options -> Preferences} zaznaczyæ checkbox "Enable developer mode". Od tej pory w menu jest widoczna nowa pozycja - \textit{debug}.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{emulator1}
    \caption{Prze³¹cznik opcji deweloperskich w emulatorze Mesen.}
\end{figure}

\subsection{NES Screen Tool}
\begin{figure}[H]
\includegraphics[width=\textwidth]{nesst.png}
\caption{Ekran g³ówny aplikacji \cite{IMG-nesscreentooloverview}}
\label{fig:figure3}
\end{figure}
NES Screen Tool to program wspomagaj¹cy tworzenie grafiki zgodnej z platform¹ NES / Famicom. Aplikacja pozwala na szczegó³owe tworzenie grafik per pixel jak i bardziej ogólne dzia³ania jak eksport przygotowanych danych do formatu zrozumia³ego przez konsolê, gotowego do zastosowania w kodzie programu.
Strona domowa \cite{nesscreentoolpage}.

\subsection{FamiTracker}
\begin{figure}[H]
\includegraphics[width=\textwidth]{famitracker.png}
\caption{Ekran g³ówny aplikacji \cite{IMG-famitrackeroverview}}
\label{fig:figure3}
\end{figure}
FamiTracker to program pozwalaj¹cy na tworzenie muzyki w stu procentach kompatybilnej z platformami NES / Famicom. Aplikacja nale¿y do rodziny trackerów - programów komputerowych w których komponuje siê muzykê wykorzystuj¹c po³¹czenie zapisu nutowego oraz poleceñ steruj¹cych efektami \cite{wikitracker}.
Strona domowa \cite{famitrackerpage}.

\begin{thebibliography}{99}
\bibitem{IMG-NintendoFamicomConsoleSetFL}
https://upload.wikimedia.org/wikipedia/commons/0/06/Nintendo-Famicom-Console-Set-FL.jpg
\bibitem{IMG-NESConsoleSet} https://upload.wikimedia.org/wikipedia/commons/8/82/NES-Console-Set.jpg
\bibitem{IMG-NewFamicom}
https://upload.wikimedia.org/wikipedia/commons/f/f1/New\_Famicom.jpg
\bibitem{IMG-NES101ConsoleSet}
https://upload.wikimedia.org/wikipedia/commons/e/e0/NES-101-Console-Set.jpg
\bibitem{IMG-GenerationNEX}
https://levelupvideogames.com/used-messiah-generation-nex-468309594161/
\bibitem{IMG-DaryarDY400656}
http://forum.pegasus-gry.com/index.php?topic=2315.0
\bibitem{IMG-GLK-2004}
https://arhn.eu/2018/04/historia-pegasusa-z-klawiatura-glk-2004-et-al/
\bibitem{IMG-Game-Axe-Color}
https://www.ign.com/articles/2000/06/10/game-axe-color
\bibitem{IMG-RetroUSBAVS}
https://upload.wikimedia.org/wikipedia/commons/7/7a/RetroUSB-AVS-Console-wController-FL.jpg
\bibitem{IMG-RetroN5}
https://cdn10.bigcommerce.com/s-2l8ru96d/products/223/images/1135/ret5bk\_\_54484.1567795736.1280.1280.jpg?c=2
\bibitem{IMG-620Games}
https://www.amazon.com/Controllers-Children-Birthday-Childhood-Memories/dp/B083RBYRYN
\bibitem{IMG-mgiq502} http://www.retrogamingmuseum.com/the-collection/micro-genius-nes-clone
\bibitem{IMG-pegiq502} https://archiwum.allegro.pl/oferta/konsola-pegasus-iq-502-pady-pudelko-plomba-i7530854084.html
\bibitem{IMG-deniq502} https://youla.ru/moskva/hobbi-razvlecheniya/konsoli-igry/dendy-classic-2-novaia-5b6c9ae1cf689a85567f44a6
\bibitem{wikiNES}
https://en.wikipedia.org/wiki/Nintendo\_Entertainment\_System
\bibitem{wikiNESClones}
https://en.wikipedia.org/wiki/Nintendo\_Entertainment\_System\_hardware\_clone
\bibitem{nesdoc} Patrick Diskin: \emph{Nintendo Entertainment System Documentation}, 2.1 2A03 Overview, http://www.nesdev.com/NESDoc.pdf
\bibitem{nesmemorymap} http://wiki.nesdev.com/w/index.php/CPU\_memory\_map
\bibitem{wikicpuppuregisters} http://wiki.nesdev.com/w/index.php/PPU\_registers\#Summary
\bibitem{wikicpuapuregisters} http://wiki.nesdev.com/w/index.php/APU\#Specification
\bibitem{famitone2} http://forums.nesdev.com/viewtopic.php?t=7329
\bibitem{nesscreentoolpage} https://shiru.untergrund.net/software.shtml
\bibitem{IMG-nesscreentooloverview} https://shiru.untergrund.net/pic/nesst.png
\bibitem{famitrackerpage} http://famitracker.com/
\bibitem{IMG-famitrackeroverview} https://blog.uptodown.com/wp-content/uploads/Famitracker-pianola.jpg.webp
\bibitem{wikitracker} https://pl.wikipedia.org/wiki/Tracker\_(oprogramowanie\_muzyczne)
\bibitem{initcode} http://wiki.nesdev.com/w/index.php/Init\_code
\bibitem{IMG-nescolors} http://wiki.nesdev.com/w/index.php/File:Savtool-swatches.png
\end{thebibliography}

\end{document}
